---
name: smart-explore
description: tree-sitter AST構造解析によるトークン効率の高いコード探索。ファイル全体を読む代わりにシンボル単位で構造を把握する。
context: fork
---

# Smart Explore

tree-sitter ASTパースによる構造的コード探索。ファイル全体をReadする代わりに、シンボル単位で必要な部分だけを取得する。

## サブエージェント

メインコンテキストから実行する場合は、`claude-mem-runner` サブエージェントに必ず委任すること。サブエージェント経由で実行することでメインコンテキストのトークン消費を抑えられる。

## いつ使うか

- ファイルの構造（関数・クラス一覧）を把握したいとき
- 特定のシンボルの実装だけを見たいとき
- コードベース横断でシンボルを検索したいとき

Serena（LSP）との違い: Serenaはセマンティック解析（参照追跡・リネーム等）、smart-exploreは折りたたみビューによるトークン節約が強み。

## 3レイヤーワークフロー

### 1. 検索 — ディレクトリ横断でシンボル発見

```text
smart_search(query="<検索語>", path="<ディレクトリ>", max_results=15)
```

シンボル名・ファイル名・ファイル内容にマッチ。折りたたみファイルビュー付きで返却される。

| パラメータ | 説明 | デフォルト |
|---|---|---|
| `query` (必須) | 検索語（シンボル名、概念、クラス名） | — |
| `path` | 検索ルートディレクトリ | cwd |
| `max_results` | 最大結果数 | 20 |
| `file_pattern` | ファイルパスフィルタ（例: `.ts`, `src/services`） | なし |

### 2. アウトライン — ファイルの構造スケルトン取得

```text
smart_outline(file_path="<ファイルパス>")
```

全シンボル（関数・クラス・メソッド・型）のシグネチャを表示、本体は折りたたみ。ファイル全体をReadするより4-8倍のトークン節約。

Step 1の折りたたみビューで十分な場合はスキップ可。

### 3. アンフォールド — 特定シンボルの実装を展開

```text
smart_unfold(file_path="<ファイルパス>", symbol_name="<シンボル名>")
```

指定シンボルのソースコード全文を返却。ASTノード境界で切り出すため、長いメソッドでも欠損なし。

## トークンコスト目安

| アプローチ | トークン | 用途 |
|---|---|---|
| `smart_outline` | ~1,000-2,000 | ファイル構造把握 |
| `smart_unfold` | ~400-2,100 | 特定シンボルの実装確認 |
| `smart_search` | ~2,000-6,000 | コードベース横断検索 |
| search + unfold | ~3,000-8,000 | 発見→確認の一連フロー |
| Read（全文） | ~12,000+ | 全体が必要な場合 |

## 標準ツールを使うべきケース

- **Grep**: 正確な文字列・正規表現検索
- **Read**: 100行以下の小さいファイル、非コードファイル（JSON, YAML, Markdown）
- **Glob**: ファイルパスパターン検索
